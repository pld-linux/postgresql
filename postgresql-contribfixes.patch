diff -uNr postgresql-7.2.orig/contrib/intarray/_int.c postgresql-7.2/contrib/intarray/_int.c
--- postgresql-7.2.orig/contrib/intarray/_int.c	Thu Oct  4 11:41:14 2001
+++ postgresql-7.2/contrib/intarray/_int.c	Fri Feb  8 14:36:08 2002
@@ -22,6 +22,7 @@
 #include "utils/array.h"
 #include "utils/builtins.h"
 #include "storage/bufpage.h"
+#include "access/tuptoaster.h"
 
 /* number ranges for compression */
 #define MAXNUMRANGE 100
@@ -358,6 +359,8 @@
 	if (entry->leafkey) {
 		r = (ArrayType *) PG_DETOAST_DATUM_COPY(entry->key);
 		PREPAREARR(r);
+		if ( VARSIZE(r) > TOAST_INDEX_TARGET )
+			elog(ERROR,"Array is too big");
 		r->flags |= LEAFKEY;
 		retval = palloc(sizeof(GISTENTRY));
 		gistentryinit(*retval, PointerGetDatum(r),
diff -uNr postgresql-7.2.orig/contrib/tsearch/README.tsearch postgresql-7.2/contrib/tsearch/README.tsearch
--- postgresql-7.2.orig/contrib/tsearch/README.tsearch	Fri Oct 12 19:19:09 2001
+++ postgresql-7.2/contrib/tsearch/README.tsearch	Fri Feb  8 14:36:08 2002
@@ -198,23 +198,6 @@
   make clean; make; make install
 
 2.
-As it was mentioned above we don't use explicitly ID of lexems
-as in OpenFTS but use hash function (crc32) instead to map lexem to
-integer. Our experiments show that probability of collision is quite small:
-for english text it's about 10**(-6) and 10**(-5) for russian collection.
-Default installation doesn't check for collisions but if your application
-does need to guarantee an exact (no collisions) search, you need 
-to update system table to mark index islossy:
-
-  update pg_amop set amopreqcheck = true where amopclaid = 
-      (select oid from pg_opclass where opcname = 'gist_txtidx_ops');
-
-If you don't bother about collisions :
-
-  update pg_amop set amopreqcheck = false where amopclaid = 
-      (select oid from pg_opclass where opcname = 'gist_txtidx_ops');
-
-3.
 txtidx doesn't preserve words ordering (this is not critical for searching)
 for performance reason, for example:
 
@@ -224,7 +207,7 @@
  'two' 'page'
 (1 row)
 
-4. 
+3. 
 Indexed access provided by txtidx data type isn't always good
 because of internal data structure we use (RD-Tree). Particularly,
 queries like '!gist' will be  slower than just a sequential scan,
@@ -265,7 +248,7 @@
 These two queries will be processed by scanning of full index !
 Very slow !
 
-5.
+4.
 Following selects produce the same result
 
   select title from titles where titleidx @@ 'patch&gist';
diff -uNr postgresql-7.2.orig/contrib/tsearch/gistidx.c postgresql-7.2/contrib/tsearch/gistidx.c
--- postgresql-7.2.orig/contrib/tsearch/gistidx.c	Fri Oct 12 19:19:09 2001
+++ postgresql-7.2/contrib/tsearch/gistidx.c	Fri Feb  8 14:36:08 2002
@@ -10,6 +10,7 @@
 #include "utils/array.h"
 #include "utils/builtins.h"
 #include "storage/bufpage.h"
+#include "access/tuptoaster.h"
 
 #include "txtidx.h"
 #include "query.h"
@@ -86,6 +87,15 @@
 	return res + 1 - a;
 }
 
+static void
+makesign( BITVECP sign, GISTTYPE *a) {
+	int4 k,len = ARRNELEM( a );
+	int4 *ptr = GETARR( a );
+	MemSet( (void*)sign, 0, sizeof(BITVEC) );
+	for(k=0;k<len;k++)
+		HASH( sign, ptr[k] );
+}
+
 Datum
 gtxtidx_compress(PG_FUNCTION_ARGS) {
 	GISTENTRY *entry = (GISTENTRY *)PG_GETARG_POINTER(0);
@@ -121,7 +131,20 @@
 			res = (GISTTYPE*)repalloc( (void*)res, len );
 			res->len = len;
 		} 	
-		
+
+		/* make signature, if array is too long */
+		if ( res->len > TOAST_INDEX_TARGET ) {
+			GISTTYPE *ressign;
+
+			len = CALCGTSIZE( SIGNKEY, 0 );
+			ressign = (GISTTYPE*)palloc( len );
+			ressign->len = len;
+			ressign->flag = SIGNKEY;
+			makesign( GETSIGN(ressign), res );
+			free(res);
+			res = ressign;
+		} 
+			
 		retval = (GISTENTRY*)palloc(sizeof(GISTENTRY));
 		gistentryinit(*retval, PointerGetDatum(res), 
 				entry->rel, entry->page,
@@ -379,14 +402,6 @@
 	PG_RETURN_POINTER( penalty );
 }
 
-static void
-makesign( BITVECP sign, GISTTYPE *a) {
-	int4 k,len = ARRNELEM( a );
-	int4 *ptr = GETARR( a );
-	MemSet( (void*)sign, 0, sizeof(BITVEC) );
-	for(k=0;k<len;k++)
-		HASH( sign, ptr[k] );
-}
 
 typedef struct {
 	bool	allistrue;
@@ -503,6 +518,11 @@
 	right = v->spl_right;
 	v->spl_nright = 0;
 
+	if ( seed_1 == 0 || seed_2 == 0 ) {
+		seed_1 = 1;
+		seed_2 = 2;
+	}
+
 	/* form initial .. */ 
 	if ( cache[seed_1].allistrue ) {
 		datum_l = (GISTTYPE*)palloc( CALCGTSIZE( SIGNKEY|ALLISTRUE, 0 ) );
diff -uNr postgresql-7.2.orig/contrib/tsearch/tsearch.sql.in postgresql-7.2/contrib/tsearch/tsearch.sql.in
--- postgresql-7.2.orig/contrib/tsearch/tsearch.sql.in	Mon Nov 26 12:45:41 2001
+++ postgresql-7.2/contrib/tsearch/tsearch.sql.in	Fri Feb  8 14:36:08 2002
@@ -171,7 +171,7 @@
    and ( tq.typname='query_txt' or tq.typname='mquery_txt' );
 
 INSERT INTO pg_amop (amopclaid, amopstrategy, amopreqcheck, amopopr)
-   SELECT opcl.oid, 1, false, c.opoid
+   SELECT opcl.oid, 1, true, c.opoid
    FROM pg_opclass opcl, txtidx_ops_tmp c
    WHERE
       opcamid = (SELECT oid FROM pg_am WHERE amname = 'gist')
@@ -179,7 +179,7 @@
       and c.oprname = '@@';
 
 INSERT INTO pg_amop (amopclaid, amopstrategy, amopreqcheck, amopopr)
-   SELECT opcl.oid, 2, false, c.opoid
+   SELECT opcl.oid, 2, true, c.opoid
    FROM pg_opclass opcl, txtidx_ops_tmp c
    WHERE
       opcamid = (SELECT oid FROM pg_am WHERE amname = 'gist')
